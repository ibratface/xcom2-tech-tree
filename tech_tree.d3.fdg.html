<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        background-color: black;
        font-family: 'Century Gothic', CenturyGothic, AppleGothic, sans-serif;
    }

    svg {
        width: 3000px;
        height: 2000px;
    }

    #title {
        color: #81D4FA;
    }

    .event {
        stroke: #8BC34A;
    }

    .facility {
        stroke: #FFCA28;
    }

    .research {
        stroke: #82B1FF;
    }

    .project {
        stroke: #EF5350;
    }

    .item {
        stroke: #3F51B5;
    }

    .drop {
        stroke: #9C27B0;
    }

    .node {
        stroke-width: 2px;
        opacity: 0.8;
        r: 5;
    }

    .text {
        stroke: none;
        fill: white;
        text-transform: uppercase;
        font-size: 12px;
        opacity: 0.8;
    }

    .link {
        stroke: #fff;
        stroke-opacity: .25;
    }
</style>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="data.js"></script>
<script>
    function initNodes(data, type, color) {
        for (var key in data) {
            data[key].name = key.split('_').join(' ');
            data[key].type = type;
            if (!data[key].requires) data[key].requires = [];
            data[key].children = [];
            data[key].weight = 0;
            data[key].row = 1;
            data[key].depth = 0;
            data[key].size = 8;
            data[key].color = color;
        }
    }

    function arrangeNodes(data) {
        // create tree structure
        for (var key in data) {
            for (var i = 0; i < data[key].requires.length; i++) {
                var parent = data[key].requires[i];
                if (data[parent]) {
                    data[parent].children.push(data[key]);
                }
            }
        }

        var byWeight = function(l, r) {
            return l.weight - r.weight;
        };

        var roots = [];
        for (var key in data) {
            if (data[key].requires.length == 0) {
                roots.push(data[key]);
            }
        }

        // figure out the depth and weight of each node
        var depth = 0;
        var walk_depth_weight = function(node) {
            var weight = 1;
            if (node.depth < depth) {
                node.depth = depth;
            }
            depth++;
            for (var i = 0; i < node.children.length; i++) {
                weight += walk_depth_weight(node.children[i]);
            }
            depth--;
            node.weight = weight;
            return weight;
        }
        for (var i = 0; i < roots.length; i++) {
            depth = 0;
            walk_depth_weight(roots[i]);
        }

        // now figure out which row to place them
        roots.sort(byWeight);

        row = 2;
        var walk_row = function(node) {
            node.row = row;
            row++;
            node.children.sort(byWeight);
            for (var i = 0; i < node.children.length; i++) {
                walk_row(node.children[i]);
            }
        }

        for (var i = 0; i < roots.length; i++) {
            walk_row(roots[i]);
        }

        return roots;
    }

    $(document).ready(function() {
        // data prep
        initNodes(events, 'event');
        initNodes(facilities, 'facility');
        initNodes(research, 'research');
        initNodes(projects, 'project');
        initNodes(items, 'item');
        initNodes(drops, 'drop');

        var data = {};
        $.extend(data, events);
        $.extend(data, research);
        $.extend(data, facilities);
        $.extend(data, items);
        $.extend(data, projects);
        $.extend(data, drops);

        arrangeNodes(data);
        var graph = {
            width: 2300,
            height: 1000,
            xOffset: 50,
            yOffset: 0,
            xSpacing: 250,
            ySpacing: 20,
            root: data['mission_gatecrasher'],
        };

        graph.nodes = [];
        graph.links = [];
        for (var key in data) {
            graph.nodes.push(data[key]);
            for (var i = 0; i < data[key].children.length; i++) {
                graph.links.push({
                    source: data[key],
                    target: data[key].children[i],
                });
            }
        }

        // normalize row and initialize node locations
        graph.nodes.sort(function(l, r) {
            return l.row - r.row;
        });
        for (var i = 0; i < graph.nodes.length; i++) {
            graph.nodes[i].row = i + 1;
            graph.nodes[i].x = graph.nodes[i].depth * graph.xSpacing + graph.xOffset;
            graph.nodes[i].y = graph.nodes[i].row * graph.ySpacing + graph.yOffset;
        }
        graph.root.fixed = true;

        var svg = d3.select("svg");
        // graph.width = $('svg').getBoundingClientRect().width;
        // graph.height = svg.getBoundingClientRect().height;
        graph.root.y = graph.height / 2;

        var force = d3.layout.force()
            .size([graph.width, graph.height])
            .gravity(3.4)
            .linkDistance(1)
            .charge(-15000)
            // .charge(function(d, i) {
            //     return -18000 + Math.pow(d.depth, 2);
            // })
            .nodes(graph.nodes)
            .links(graph.links);

        var link = svg.selectAll(".link")
            .data(graph.links)
            .enter().append("line")
            .attr("class", "link");

        var node = svg.selectAll(".node")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("class", function(d) {
                return "node " + d.type;
            });

        var text = svg.selectAll(".text")
            .data(graph.nodes)
            .enter().append("text")
            .attr("class", function(d) {
                return "text " + d.type;
            })
            .text(function(d) {
                return d.name;
            });

        var first = true;
        force.on("tick", function(e) {
            var k = 8 * e.alpha;
            graph.nodes.forEach(function(d, i) {
                if (first)
                    d.x += (d.depth * graph.xSpacing + graph.xOffset - d.x) * k;
                else
                    d.x = d.depth * graph.xSpacing + graph.xOffset;
            });

            graph.links.forEach(function(d, i) {
                // d.target.x += (((d.source.depth)^3)*50 - d.target.x * 0.5) * ky;
                // d.target.y += ((d.source.weight)^(d.target.depth+1) - d.target.y * 0.001) * ky;
            });

            link
                .attr("x1", function(d) {
                    return d.source.x;
                })
                .attr("y1", function(d) {
                    return d.source.y;
                })
                .attr("x2", function(d) {
                    return d.target.x;
                })
                .attr("y2", function(d) {
                    return d.target.y;
                });

            node.attr("cx", function(d) {
                    return d.x;
                })
                .attr("cy", function(d) {
                    return d.y;
                });

            text.attr("x", function(d) {
                    var bbox = this.getBBox();
                    return d.x + 15;
                })
                .attr("y", function(d) {
                    var bbox = this.getBBox();
                    return d.y + (bbox.height / 4);
                });
        });

        force.start();
        setTimeout(function() {
            first = false;
            force.start();
        }, 5100);
    });
</script>

<body>
    <h1 id="title">XCOM 2 TECH TREE</h1>
    <svg></svg>
</body>
